---
title: "UPS1 in yeast background at 5fmol, 10fmol and 25fmol concentration for mspip benchmarking"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(limma)
devtools::load_all("/stornext/General/data/academic/lab_davis/prot/benchmarking/msImpute/")
```

```{r include=TRUE}
data <- read.delim("/stornext/General/data/academic/lab_davis/prot/benchmarking/PXD002370/txt/evidence.txt", stringsAsFactors = FALSE)

table(data$Type)

# data <- data[grep("CON_|REV_", data$Leading.razor.protein, invert=TRUE),]
data <- data[data$Charge > 1,]
data$PeptideID <- paste0(data$Modified.sequence, data$Charge)
data$matrix.row.id <- paste(data$PeptideID, data$Leading.Razor.Protein, sep ="_")


genes <- data[,c("PeptideID","matrix.row.id", "Leading.Razor.Protein")]
genes <- genes[!duplicated(genes),]


y <- evidenceToMatrix(data) # [grepl("MULTI-MSMS|MULTI-SECPEP", data$Type),]

genes <- genes[match(rownames(y), genes$PeptideID),]

#table(grepl("ups", data$Leading.Razor.Protein))
```


```{r include=TRUE}
dda_pip <- mspip("/stornext/General/data/academic/lab_davis/prot/benchmarking/PXD002370/txt", 
                 k=15, thresh = 0.5, tims_ms = FALSE, skip_weights = TRUE)

#table(grepl("CON|REV", dda_pip$PeptideID))
# dda_pip <- dda_pip[grep("CON|REV", dda_pip$PeptideID, invert=TRUE),]
dda_pip <- dda_pip[ as.numeric(gsub("(.*)_(.*)","\\2", dda_pip$PeptideID)) > 1,]

y_pip <- evidenceToMatrix(dda_pip, return_EList = FALSE)




# do not filter - keep all but down-weight in model fitting step
dda_pip2 <- mspip("/stornext/General/data/academic/lab_davis/prot/benchmarking/PXD002370/txt", 
                  k=15, thresh = 0.0,
                  tims_ms = FALSE, skip_weights = FALSE)

hist(dda_pip2$weight)
dda_pip2 <- dda_pip2[as.numeric(gsub("(.*)_(.*)","\\2", dda_pip2$PeptideID)) > 1,]
y_pip_elist <- evidenceToMatrix(dda_pip2, return_EList = TRUE, weights = "weight")
```



```{r include=TRUE, fig.cap="Proportion of missing peptides per run in original data, PIP results filtered by confidence threshold, PIP unfiltered."}
library(ggplot2)
library(patchwork)
library(ggsci)


p_missing_y <- colMeans(is.na(y))
p_missing_ypip <- colMeans(is.na(y_pip))
p_missing_ypipall <- colMeans(is.na(y_pip_elist$E))

ggdatm <- data.frame(mdata = c(p_missing_y, p_missing_ypip, p_missing_ypipall),
                   method = rep(c("data","PIP_filterlowConf", "PIP_keepall"),
                                c(length(p_missing_y), length(p_missing_ypip), length(p_missing_ypipall))),
                   samples = as.factor(
                     as.numeric(as.factor(c(names(p_missing_y), names(p_missing_ypip),
                                            names(p_missing_ypipall))))
                   )
)


ggdatm$method <- as.factor(ggdatm$method)

ggplot(ggdatm, aes(x=samples, y = mdata, fill = method)) + 
  geom_bar(stat='identity', position='dodge') + scale_fill_npg() +
  ylab("Fraction missing peptides")

```



```{r include=TRUE}


y_dda <- log2(y)
y <- log2(y)
ypip <- log2(y_pip)


y_pip <- log2(y_pip)

y_pip_elist <- y_pip_elist


targets <- read.delim("/stornext/General/data/academic/lab_davis/prot/benchmarking/PXD002370/Ratio2.5_experimentalDesignTemplate.txt")
group <- as.factor(gsub("(.*)-R[123]", "\\1", targets$Experiment))

design <- model.matrix(~ group)
```




```{r include=TRUE}
rownames(y) <- genes$matrix.row.id[match(rownames(y), genes$PeptideID)]
rownames(y_dda) <- genes$matrix.row.id[match(rownames(y_dda), genes$PeptideID)]
rownames(y_pip_elist) <- genes$matrix.row.id[match(rownames(y_pip_elist), genes$PeptideID)]
rownames(y_pip) <- genes$matrix.row.id[match(rownames(y_pip), genes$PeptideID)]
rownames(ypip) <- genes$matrix.row.id[match(rownames(ypip), genes$PeptideID)]


# make sure idents do not change for identified peptides (i.e. identified peptides are not replaced with wrong intesity/identification)

y["_(ac)ADITDKTAEQIENINIQDDQK_2_sp|P04147|PABP_YEAST",]
y_pip["_(ac)ADITDKTAEQIENINIQDDQK_2_sp|P04147|PABP_YEAST",]
```


```{r}
keep1 <- (!grepl("CON__|REV__", y_pip_elist$genes$Leading.Razor.Protein))
keep2 <- (y_pip_elist$genes$Modifications %in% "Unmodified")


keep3 <- (!grepl("CON__|REV__", genes$Leading.Razor.Protein))
keep4 <- (!grepl("[a-z]+", genes$PeptideID))

y_dda <- y_dda[keep3&keep4,]
# y <- normalizeBetweenArrays(log2(y[keep1&keep2,]), method = "quantile")
y <- y[keep3&keep4,]
ypip <- y_pip[keep1&keep2,]

# y_pip <- normalizeBetweenArrays(log2(y_pip)[keep1&keep2,], method = "quantile")
y_pip <- y_pip[keep1&keep2,]
# y_pip_elist <- normalizeBetweenArrays(y_pip_elist[keep1&keep2,], method = "quantile")
y_pip_elist <- y_pip_elist[keep1&keep2,]


targets <- read.delim("/stornext/General/data/academic/lab_davis/prot/benchmarking/PXD002370/experimentalDesignTemplate.txt")
group <- as.factor(gsub("(.*)-R[123]", "\\1", targets$Experiment))

design <- model.matrix(~ group)
```



### imputation (barycenter + SOTA methods)
```{r include=TRUE}
library(imputeLCMD)
library(limma)
library(ggplot2)
library(ggsci)
library(rrcovNA)

impute.perseus <- function(x, width=0.3, shift=1.8) {
  # distributions are induced by measured values in each sample
  data.mean <- colMeans(x, na.rm = TRUE)
  data.sd <- matrixStats::colSds(x, na.rm = TRUE)
  n <- nrow(x)
  z <- rmvnorm(n, mean = data.mean - shift*data.sd , sigma = diag(data.sd*width))
  x[is.na(x)] <- z[is.na(x)]
  return(x)
}

## Dataset has UPS spike-ins
# masterMix_proteins <- c("P02754","P80025","P00921","P00366","P02662","P61823",
#                         "P02789","P12799","P02676","P02672", "P02666","P68082") 

```


```{r results='hide', include=TRUE}
# barycenter approach requires rank 2
y_msImpute <- msImpute(y_dda[rowSums(!is.na(y_dda)) >= 4,], 
                       rank.max = 2,
                       method = "v2-mnar",
                       #method = "v2",
                       group = group)

y_msImpute_defaultrank <- msImpute(y_dda[rowSums(!is.na(y_dda)) >= 4,], 
                       # rank.max = 2,
                       #method = "v2-mnar",
                       method = "v1",
                       group = group)



par(mfrow=c(1,2))
pcv <- plotCV2(y_msImpute, main = "rank2")
pcv <- plotCV2(y_msImpute_defaultrank, main = "default rank (r=3)")


y_msImpute_pip <- msImpute(ypip[rowSums(!is.na(ypip)) >= 4,], 
                       rank.max = 2,
                      method = "v2-mnar",
                        # method = "v2",
                       group = group)




y_MLE <- impute.wrapper.MLE(y_dda)
# y_impSeq <- impSeq(y_dda[rowSums(!is.na(y_dda)) >= 4,])
y_impSeq <- impSeq(y_dda[(rowSums(!is.na(y_dda)) >= 2),])
# y_knn <- impute.wrapper.KNN(y_dda[rowSums(!is.na(y_dda)) >= 4,], K = 15)
y_knn <- impute.wrapper.KNN(y_dda[(rowSums(!is.na(y_dda)) >= 2),], K = 15)


y_minDet <- impute.MinDet(y_dda, q = 0.01)


# y_minProb <- impute.MinProb(y_dia,  0.3,  1.8)

y_perseus <- impute.perseus(y_dda)



# pcv <- plotCV2(limma::normalizeBetweenArrays(y_perseus,
#                                              method = 'quantile'), 
#                main = "perseus")

y_qrilc <- impute.QRILC(y_dda, 1)[[1]]



sOa_imps <- readRDS("/stornext/Home/data/allstaff/h/hediyehzadeh.s/softImpute_low_rank_experimentation/impute_PXD002370_sOa_filter4obs_noNorm.rds")
names(sOa_imps) <- c("RF","Mice","EM","BPCA","LLS")

sOa_imps <- sOa_imps[c("RF","Mice","EM","BPCA")]

z <- m <- rownames(sOa_imps[[1]])
#m <- paste0("_", m)

# rowsname <- rownames(y)[rownames(y) %in% m]
rowsname <- rownames(y_msImpute_pip)[rownames(y_msImpute_pip) %in% m]
rowsname <- intersect(rowsname, rownames(y_knn))
rowsname <- intersect(rownames(y_dda[rowSums(!is.na(y_dda)) >= 4,]), rownames(y_pip))

rowsname <- rownames(y_dda)[!(rowSums(is.na(y_dda)) >=2 )]

mats <- list(#"MLE"=y_MLE[rowsname,],
             "KNN"= y_knn,
             # "Perseus"= y_perseus[rowsname,],
             "impSeq" = y_impSeq,
             # "QRILC" = y_qrilc[rowsname,],
             #"PIP_k=15" = y_pip[(rowSums(!is.na(y_pip)) >= 2),],
             #"PIP_weight" = y_pip_elist[rowsname,],
             "barycenter" = y_msImpute,
             #"PIP_barycenter" = y_msImpute_pip,
             "baseline" = y[(rowSums(!is.na(y)) >= 2),])


mats <- c(sOa_imps, mats)


n_ups <- 500


topN <- list()
fullTables <- list()
fullTables2 <- list()
for(i in seq_along(mats)){
  message("processing ", names(mats)[i])
   E <- normalizeBetweenArrays(mats[[i]], method = "quantile")
   # E <- normalizeMedianValues(mats[[i]])
   fit <- lmFit(E, design = design)

   fit <- eBayes(fit)
   print(summary(decideTests(fit)))

  tp <- topTable(fit, coef=ncol(fit), number = Inf, p.value = 1)
  tp$de <- ifelse(tp$adj.P.Val < 0.05,1,0)
  # tp$isUPS <- ifelse(gsub("(.*)_(.*)_(.*)","\\3", rownames(tp)) %in% masterMix_proteins,1,0)
  tp$isUPS <- ifelse(grepl("upsedyp", rownames(tp) ),1,0)
  #tp$isdeUPS <- ifelse(tp$isUPS==1 & tp$de==1,1,0)
  tp$TP <- ifelse(tp$de==1 & tp$isUPS==1,1,0) # a ups called DE is a true positive
  tp$FN <- ifelse(tp$de==0 & tp$isUPS==1,1,0) # a ups called not DE is a false negative
  tp$fd <- ifelse(tp$isUPS==0 & tp$de ==1 ,1,0) # & !complete.cases(y_dda[match(rownames(tp), rownames(y_dda)),])
  tp$FDR <- cumsum(tp$fd)/cumsum(tp$de)
  topN[[names(mats)[i]]] <- data.frame(N=seq_len(n_ups),
                                       numUPS=cumsum(tp$isUPS)[seq_len(n_ups)],
                                       #numUPS=cumsum(tp$TP)[seq_len(n_ups)],
                                       FDR=tp$FDR[seq_len(n_ups)],
                                       nominalFDR= ifelse(seq_len(n_ups) == which(tp$adj.P.Val > 0.05)[1],1,0),
                                       method=names(mats)[i])
  
  
  #tp <- tp[order(tp$P.Value, decreasing = TRUE),]

  fullTables[[names(mats)[i]]] <- data.frame(
    
    # TP = cumsum(tp$TP),
    # FN = cumsum(tp$FN),
    # FDR = tp$FDR,
    # FP = cumsum(tp$fd),
    # nominalFDR_5percent = ifelse(seq_len(nrow(tp)) == which(tp$adj.P.Val > 0.05)[1], 1, 0),
    # nominalFDR_10percent = ifelse(seq_len(nrow(tp)) == which(tp$adj.P.Val > 0.1)[1], 1, 0),
    # method=names(mats)[i]
    
    # replace with labels and predictions to use pROC
    predictions = -log10(tp$P.Value),
    labels = tp$isUPS
    
    
    
    )
  
  fullTables2[[names(mats)[i]]] <- data.frame(
    
    # TP = cumsum(tp$isUPS)/cumsum(tp$de),
    # FP = (cumsum(1-tp$isUPS)/cumsum(tp$de))
    
    # TP = cumsum(tp$isUPS),
    # FP = cumsum(1-tp$isUPS)
    
    TP = cumsum(tp$TP),
    FP = cumsum(tp$fd)
    
    

    
    )
}


topN <- do.call(rbind, topN)
fullTables <- do.call(rbind, fullTables)
fullTables$method <- gsub("(.*)\\.(.*)","\\1", rownames(fullTables))


fullTables2 <- do.call(rbind, fullTables2)
fullTables2$method <- gsub("(.*)\\.(.*)","\\1", rownames(fullTables2))

# fullTables[fullTables$nominalFDR_5percent==1,]
```

### Top N and ROC evaluations
```{r include=TRUE, fig.cap="Number of True Positives and False Positives (Left) and ROC curves (right) for the Barycenter, PIP and state-of-the-art imputation approaches.", out.width="95%", fig.width=12}
library(plotROC)

p2 <- ggplot(fullTables, aes(m = predictions, d = labels, group = method, color = method))+ geom_roc(n.cuts=3,labels=FALSE) +
   style_roc() + 
   #geom_rocci(fill="pink") +
   scale_color_npg()



# p1 <- ggplot(topN, aes(y=numUPS, x=N, color=method)) +
#   geom_line(size=1.5) + scale_color_simpsons() + theme_minimal() +
#   labs(title = "PASS00589-DDA") + xlab("Top N peptides") + ylab("Number of spiked peptides")

fullTables2$method <- factor(fullTables2$method, 
                             levels = c("BPCA", "EM", "impSeq", "KNN", "Mice", "RF","baseline","barycenter"))

p1 <- ggplot(fullTables2, aes(y=TP, x=FP, color=method, group = method)) +
  geom_line(size=1) + 
  scale_color_npg() + 
  #scale_color_simpsons() +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5), axis.text=element_text(colour="black")) + 
  labs(title = "PXD002370") + xlab("False Positives") + ylab("True Positives")

# p1 + p2

p1

```


