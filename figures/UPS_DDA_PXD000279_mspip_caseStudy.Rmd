---
title: "UPS_DDA_PXD000279_mspip_caseStudy"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(limma)
devtools::load_all("/stornext/General/data/academic/lab_davis/prot/benchmarking/msImpute/")
```


```{r include=TRUE}
dda_pip <- mspip("/stornext/General/data/academic/lab_davis/prot/spikeIn_maxLFQpaper/txt", 
                 k=3, thresh = 0.5, tims_ms = FALSE, skip_weights = TRUE)

#table(grepl("CON|REV", dda_pip$PeptideID))
# dda_pip <- dda_pip[grep("CON|REV", dda_pip$PeptideID, invert=TRUE),]
dda_pip <- dda_pip[ as.numeric(gsub("(.*)_(.*)","\\2", dda_pip$PeptideID)) > 1,]

y_pip <- evidenceToMatrix(dda_pip, return_EList = FALSE)




# do not filter - keep all but down-weight in model fitting step
dda_pip2 <- mspip("/stornext/General/data/academic/lab_davis/prot/spikeIn_maxLFQpaper/txt", k=3, thresh = 0.0,
                  tims_ms = FALSE, skip_weights = FALSE)

hist(dda_pip2$weight)
dda_pip2 <- dda_pip2[as.numeric(gsub("(.*)_(.*)","\\2", dda_pip2$PeptideID)) > 1,]
y_pip_elist <- evidenceToMatrix(dda_pip2, return_EList = TRUE, weights = "weight")
```

```{r include=TRUE}
data <- read.delim("/stornext/General/data/academic/lab_davis/prot/spikeIn_maxLFQpaper/txt/evidence.txt", stringsAsFactors = FALSE)


# data <- data[grep("CON_|REV_", data$Leading.razor.protein, invert=TRUE),]
data <- data[data$Charge > 1,]
data$PeptideID <- paste0(data$Modified.sequence, data$Charge)
data$matrix.row.id <- paste(data$PeptideID, data$Leading.razor.protein, sep ="_")
# data <- data[!data$Type %in% "MULTI-MATCH",]


genes <- data[,c("PeptideID","matrix.row.id", "Leading.razor.protein")]
genes <- genes[!duplicated(genes),]


y <- evidenceToMatrix(data)

# the are some "ALL NA" rows
y <- y[!(rowSums(is.na(y)) == ncol(y)),]

genes <- genes[match(rownames(y), genes$PeptideID),]

#table(grepl("ups", data$Leading.Razor.Protein))

```


```{r include=TRUE, fig.cap="Proportion of missing peptides per run in original data, PIP results filtered by confidence threshold, PIP unfiltered."}
library(ggplot2)
library(patchwork)
library(ggsci)


p_missing_y <- colMeans(is.na(y))
p_missing_ypip <- colMeans(is.na(y_pip))
p_missing_ypipall <- colMeans(is.na(y_pip_elist$E))

ggdatm <- data.frame(mdata = c(p_missing_y, p_missing_ypip, p_missing_ypipall),
                   method = rep(c("data","PIP_filterlowConf", "PIP_keepall"),
                                c(length(p_missing_y), length(p_missing_ypip), length(p_missing_ypipall))),
                   samples = as.factor(
                     as.numeric(as.factor(c(names(p_missing_y), names(p_missing_ypip),
                                            names(p_missing_ypipall))))
                   )
)


ggdatm$method <- as.factor(ggdatm$method)

(p <- ggplot(ggdatm, aes(x=samples, y = mdata, fill = method)) + 
  geom_bar(stat='identity', position='dodge') + scale_fill_npg() +
  ylab("Fraction missing peptides") + theme_classic() +
  theme(axis.text=element_text(colour="black")))

```



```{r include=TRUE}
y_dda <- log2(y)
y <- log2(y)
ypip <- log2(y_pip)


y_pip <- log2(y_pip)

# y_pip_elist <- y_pip_elist
```



```{r include=TRUE}
rownames(y) <- genes$matrix.row.id[match(rownames(y), genes$PeptideID)]
rownames(y_dda) <- genes$matrix.row.id[match(rownames(y_dda), genes$PeptideID)]
rownames(y_pip_elist) <- genes$matrix.row.id[match(rownames(y_pip_elist), genes$PeptideID)]
rownames(y_pip) <- genes$matrix.row.id[match(rownames(y_pip), genes$PeptideID)]
rownames(ypip) <- genes$matrix.row.id[match(rownames(ypip), genes$PeptideID)]

table(grepl("ups", rownames(y_dda)))
```


```{r include=TRUE}
keep1 <- (!grepl("CON__|REV__", y_pip_elist$genes$Leading.razor.protein))
keep2 <- (y_pip_elist$genes$Modifications %in% "Unmodified")

table(keep1&keep2)

keep3 <- (!grepl("CON__|REV__", genes$Leading.razor.protein))
keep4 <- (!grepl("[a-z]+", genes$PeptideID))


table(keep3&keep4)

y_dda <- y_dda[keep3&keep4,]
# y <- normalizeBetweenArrays(log2(y[keep1&keep2,]), method = "quantile")
y <- y[keep3&keep4,]
ypip <- y_pip[keep1&keep2,]

# y_pip <- normalizeBetweenArrays(log2(y_pip)[keep1&keep2,], method = "quantile")
y_pip <- y_pip[keep1&keep2,]
# y_pip_elist <- normalizeBetweenArrays(y_pip_elist[keep1&keep2,], method = "quantile")
y_pip_elist <- y_pip_elist[keep1&keep2,]




group <- gsub(".*_(UPS[12])_.*",
              "\\1",
              colnames(y_pip))

design <- model.matrix(~ group)
```

```{r eval = FALSE}
ups_data <- read.delim("/stornext/General/data/academic/lab_davis/prot/benchmarking/PXD000279/dynamicrangebenchmark/peptides.txt", stringsAsFactors = FALSE)


ups_data <- ups_data[grep("CON__|REV__", ups_data$Leading.razor.protein, invert=TRUE),]


ups_data$PeptideID <- paste(ups_data$Sequence, ups_data$Charges, ups_data$Leading.razor.protein, sep="_")
y <- ups_data[,grep("Intensity.UPS", colnames(ups_data))]
rownames(y) <- ups_data$PeptideID

# confirm UPS peptides are in the expression matrix



y[y == 0] <- NA
keep <- rowSums(!is.na(y)) >= 4


y <- y[keep,]
y <- log2(as.matrix.data.frame(y))
y_dda <- y
```

### imputation (barycenter + SOTA methods)
```{r include=TRUE}
library(imputeLCMD)
library(limma)
library(ggplot2)
library(ggsci)
library(rrcovNA)

impute.perseus <- function(x, width=0.3, shift=1.8) {
  # distributions are induced by measured values in each sample
  data.mean <- colMeans(x, na.rm = TRUE)
  data.sd <- matrixStats::colSds(x, na.rm = TRUE)
  n <- nrow(x)
  z <- rmvnorm(n, mean = data.mean - shift*data.sd , sigma = diag(data.sd*width))
  x[is.na(x)] <- z[is.na(x)]
  return(x)
}


```




```{r results='hide', include=TRUE}

y_msImpute <- msImpute(y_dda[rowSums(!is.na(y_dda)) >= 4,], 
                       rank.max = 2, 
                       method = "v2-mnar", 
                       group = group)

y_msImpute_mnar <- msImpute(y_dda[rowSums(!is.na(y_dda)) >= 4,], 
                       #rank.max = 2, 
                       method = "v2-mnar", 
                       group = group)

y_msImpute_pip <- msImpute(ypip[rowSums(!is.na(ypip)) >= 4,], 
                       rank.max = 2, 
                       method = "v2-mnar",
                        # method = "v1",
                       group = group)



par(mfrow=c(2,2))
bcv <- plotCV2(y_dda, main = "MQ")
bcv <- plotCV2(y_msImpute, main = "rank2-bary")
bcv <- plotCV2(y_msImpute_mnar, main = "v2-mnar")
bcv <- plotCV2(y_msImpute_pip, main = "pip-v1")

y_MLE <- impute.wrapper.MLE(y_dda)
y_impSeq <- impSeq(y_dda[rowSums(!is.na(y_dda)) >= 2,])
y_knn <- impute.wrapper.KNN(y_dda[rowSums(!is.na(y_dda)) >= 2,], K = 15)


y_minDet <- impute.MinDet(y_dda, q = 0.01)
# y_minProb <- impute.MinProb(y_dia,  0.3,  1.8)

y_perseus <- impute.perseus(y_dda)

# pcv <- plotCV2(limma::normalizeBetweenArrays(y_perseus,
#                                              method = 'quantile'), 
#                main = "perseus")

y_qrilc <- impute.QRILC(y_dda, 1)[[1]]


sOa_imps <- readRDS("/stornext/Home/data/allstaff/h/hediyehzadeh.s/softImpute_low_rank_experimentation/impute_PXD000279_sOa_filter4obs_noNorm_WEHI.rds")
names(sOa_imps) <- c("RF","Mice","EM","BPCA","LLS")

sOa_imps <- sOa_imps[c("RF","Mice","EM","BPCA")]



par(mfrow=c(2,2))
bcv <- plotCV2(y_dda, main = "MQ")
bcv <- plotCV2(log2(y_pip_elist$E), main = "pip_keepall")
bcv <- plotCV2(sOa_imps[["RF"]], main = "RF")
bcv <- plotCV2(y_msImpute, main = "rank2-bary")






z <- m <- rownames(sOa_imps[[1]])
# m <- paste0("_", m)

# rowsname <- rownames(y_msImpute)[rownames(y_msImpute) %in% m]

rowsname <- rownames(y)[rownames(y) %in% m]

rowsname <- intersect(rownames(y_pip), m)


mats <- list(#"MLE"=y_MLE[rowsname,],
             "KNN"= y_knn,
             #"Perseus"= y_perseus[rowsname,],
             # "QRILC" = y_qrilc[rowsname,],
             # "dia" = y_dia,
             "PIP" = y_pip,
             "PIP_weight" = y_pip_elist,
             "impSeq" = y_impSeq,
             "barycenter" = y_msImpute,
             # "barycenter_PIP" = y_msImpute_pip[rowsname,],
             "baseline" = y)





mats <- c(sOa_imps, mats)






n_ups <- 500


topN <- list()
fullTables <- list()
fullTables2 <- list()
for(i in seq_along(mats)){
  message("processing ", names(mats)[i])
   E <- normalizeBetweenArrays(mats[[i]], method = "quantile")
  # E <- normalizeMedianAbsValues(mats[[i]])

   fit <- lmFit(E, design = design)
   
   fit <- eBayes(fit)
   print(summary(decideTests(fit)))

  tp <- topTable(fit, coef=ncol(fit), number = Inf, p.value = 1)
  tp$de <- ifelse(tp$adj.P.Val < 0.05,1,0)
  tp$isUPS <- ifelse(grepl("ups", rownames(tp)),1,0)
  #tp$isdeUPS <- ifelse(tp$isUPS==1 & tp$de==1,1,0)
  tp$TP <- ifelse(tp$de==1 & tp$isUPS==1,1,0) # a ups called DE is a true positive
  tp$FN <- ifelse(tp$de==0 & tp$isUPS==1,1,0) # a ups called not DE is a false negative
  tp$fd <- ifelse(tp$isUPS==0 & tp$de ==1 ,1,0) # & !complete.cases(y_dda[match(rownames(tp), rownames(y_dda)),])
  tp$FDR <- cumsum(tp$fd)/cumsum(tp$de)
  topN[[names(mats)[i]]] <- data.frame(N=seq_len(n_ups),
                                       numUPS=cumsum(tp$isUPS)[seq_len(n_ups)],
                                       #numUPS=cumsum(tp$TP)[seq_len(n_ups)],
                                       FDR=tp$FDR[seq_len(n_ups)],
                                       nominalFDR= ifelse(seq_len(n_ups) == which(tp$adj.P.Val > 0.05)[1],1,0),
                                       method=names(mats)[i])
  
  
  #tp <- tp[order(tp$P.Value, decreasing = TRUE),]

  fullTables[[names(mats)[i]]] <- data.frame(
    
    # TP = cumsum(tp$TP),
    # FN = cumsum(tp$FN),
    # FDR = tp$FDR,
    # FP = cumsum(tp$fd),
    # nominalFDR_5percent = ifelse(seq_len(nrow(tp)) == which(tp$adj.P.Val > 0.05)[1], 1, 0),
    # nominalFDR_10percent = ifelse(seq_len(nrow(tp)) == which(tp$adj.P.Val > 0.1)[1], 1, 0),
    # method=names(mats)[i]
    
    # replace with labels and predictions to use pROC
    predictions = -log10(tp$P.Value),
    labels = tp$isUPS
    
    
    
    )
  
  fullTables2[[names(mats)[i]]] <- data.frame(
    
    # TP = cumsum(tp$isUPS)/cumsum(tp$de),
    # FP = (cumsum(1-tp$isUPS)/cumsum(tp$de))
    
    # TP = cumsum(tp$isUPS),
    # FP = cumsum(1-tp$isUPS)
    
    TP = cumsum(tp$TP),
    FP = cumsum(tp$fd)
    
    

    
    )
}


topN <- do.call(rbind, topN)
fullTables <- do.call(rbind, fullTables)
fullTables$method <- gsub("(.*)\\.(.*)","\\1", rownames(fullTables))


fullTables2 <- do.call(rbind, fullTables2)
fullTables2$method <- gsub("(.*)\\.(.*)","\\1", rownames(fullTables2))

```

### Top N and ROC evaluations
```{r include=TRUE, fig.cap="Number of True Positives and False Positives (Left) and ROC curves (right) for the Barycenter, PIP and state-of-the-art imputation approaches.", out.width="95%", fig.width=12}
library(plotROC)
library(patchwork)

p2 <- ggplot(fullTables, aes(m = predictions, d = labels, group = method, color = method))+ geom_roc(n.cuts=3,labels=FALSE) +
   style_roc() + 
   #geom_rocci(fill="pink") +
   scale_color_npg()



# p1 <- ggplot(topN, aes(y=numUPS, x=N, color=method)) +
#   geom_line(size=1.5) + scale_color_simpsons() + theme_minimal() +
#   labs(title = "PASS00589-DDA") + xlab("Top N peptides") + ylab("Number of spiked peptides")


p1 <- ggplot(fullTables2, aes(y=TP, x=FP, color=method, group = method)) +
  geom_line(size=1) + scale_color_npg() + theme_classic() +
  theme(plot.title = element_text(hjust = 0.5), axis.text=element_text(colour="black")) + 
  labs(title = "PXD000279-DDA") + xlab("False Positives") + ylab("True Positives")

p1 + p2
```


